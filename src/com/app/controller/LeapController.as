// com.adam.utils.LeapController// Adam Riggs//package com.app.controller{	import com.adam.events.MuleEvent;	import com.adam.utils.Utils;	import com.greensock.TweenNano;	import com.leapmotion.leap.Finger;	import com.leapmotion.leap.Frame;	import com.leapmotion.leap.Gesture;	import com.leapmotion.leap.Hand;	import com.leapmotion.leap.LeapMotion;	import com.leapmotion.leap.Pointable;	import com.leapmotion.leap.SwipeGesture;	import com.leapmotion.leap.Tool;	import com.leapmotion.leap.events.LeapEvent;		//import flash.utils.getTimer;
		public class LeapController {				//vars		protected var _active:Boolean;		protected var _gestureStart:Boolean;		protected var _gestureDuration:Number;		protected var _palmVelocityThreshold:int;		protected var _tipVelocityThreshold:int;		protected var _tipWagRightCount:int;		protected var _tipWagLeftCount:int;		protected var _stillVelocityThreshold:int;				protected var _noFingers:Boolean;		protected var _swipeLeft1:Boolean;		protected var _swipeRight1:Boolean;		protected var _swipeLeft2:Boolean;		protected var _swipeRight2:Boolean;		protected var _swipeLeft3:Boolean;		protected var _swipeRight3:Boolean;		protected var _swipeLeft4:Boolean;		protected var _swipeRight4:Boolean;		protected var _poke:Boolean;		protected var _fingerWag:Boolean;				protected var _gesturesVector:Vector.<Boolean>;				protected var _palmY:Number;		protected var _fingerCount:int;				//objects		private var utils:Utils=Utils.instance;		private var _leap:LeapMotion;		protected var _frame:Frame;		protected var _hands:Vector.<Hand>;		protected var _fingers:Vector.<Finger>;		protected var _tools:Vector.<Tool>;		protected var _pointables:Vector.<Pointable>;		protected var _gestures:Vector.<Gesture>;				protected var _swipe:SwipeGesture;				//const		public static const NAME:String="leapController";		public const RETURNTYPE:String=NAME;				public static const SWIPE_RIGHT:String="swiperight";		public static const SWIPE_LEFT:String="swipeleft";				/** Storage for the singleton instance. */		private static const _instance:LeapController = new LeapController(LeapControllerLock);				public function LeapController(lock:Class){			if (lock != LeapControllerLock)			{				throw new Error("Invalid LeapController access.  Use LeapController.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{			_active=false;						_palmY=0;			_fingerCount=0;			_palmVelocityThreshold=500;			_stillVelocityThreshold=50;			_tipVelocityThreshold=500;			_tipWagRightCount=0;			_tipWagLeftCount=0;			_gestureDuration=.4;						_noFingers=false;			_swipeLeft1=false;			_swipeRight1=false;			_swipeLeft2=false;			_swipeRight2=false;			_swipeLeft3=false;			_swipeRight3=false;			_swipeLeft4=false;			_swipeRight4=false;			_poke=false;			_fingerWag=false;						_gesturesVector=new Vector.<Boolean>;			_gesturesVector.push(_swipeLeft1);			_gesturesVector.push(_swipeRight1);			_gesturesVector.push(_swipeLeft2);			_gesturesVector.push(_swipeRight2);			_gesturesVector.push(_swipeLeft3);			_gesturesVector.push(_swipeRight3);			_gesturesVector.push(_swipeLeft4);			_gesturesVector.push(_swipeRight4);			_gesturesVector.push(_poke);			_gesturesVector.push(_fingerWag);														}				private function initEvents():void{			//utils.em.listen(NAME, onLeapController);		}				private function initObjs():void{			_leap=new LeapMotion();			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_INIT, onInit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_CONNECTED, onConnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_DISCONNECTED, onDisconnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_EXIT, onExit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_FRAME, onFrame );			//			_leap.controller.enableGesture( Gesture.TYPE_CIRCLE );//			_leap.controller.enableGesture( Gesture.TYPE_KEY_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SCREEN_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SWIPE );		}		//*****Core Functionality				protected function endGesture():void{			debug("endGesture()");			_gestureStart=false;			for(var i:uint=0;i<_gesturesVector.length;i++){				_gesturesVector[i]=false;			}		}				//0 fingers		public function getNoFingers():Boolean{			if(_noFingers){				_noFingers=false;				return true;			}			return false;		}				//1 finger		public function getSwipeLeft1():Boolean{			if(_swipeLeft1){				_swipeLeft1=false;				return true;			}			return false;		}				public function getSwipeRight1():Boolean{			if(_swipeRight1){				_swipeRight1=false;				return true;			}			return false;		}				//2 fingers		public function getSwipeLeft2():Boolean{			if(_swipeLeft2){				_swipeLeft2=false;				return true;			}			return false;		}				public function getSwipeRight2():Boolean{			if(_swipeRight2){				_swipeRight2=false;				return true;			}			return false;		}				//3 fingers		public function getSwipeLeft3():Boolean{			if(_swipeLeft3){				_swipeLeft3=false;				return true;			}			return false;		}				public function getSwipeRight3():Boolean{			if(_swipeRight3){				_swipeRight3=false;				return true;			}			return false;		}				//4 fingers		public function getSwipeLeft4():Boolean{			if(_swipeLeft4){				_swipeLeft4=false;				return true;			}			return false;		}				public function getSwipeRight4():Boolean{			if(_swipeRight4){				_swipeRight4=false;				return true;			}			return false;		}				//poke		public function getPoke():Boolean{			if(_poke){				_poke=false;				return true;			}			return false;		}				//finger wag		public function getFingerWag():Boolean{			if(_fingerWag){				_fingerWag=false;				return true;			}			return false;		}				private function fingerWagLeft():void{			_tipWagLeftCount++;		}				private function fingerWagRight():void{			_tipWagRightCount++;		}				private function checkFingerWag():void{			if(_tipWagRightCount>0 && _tipWagLeftCount>0){				debug("fingerWag");				_fingerWag=true;				_gestureStart=true;								_tipWagRightCount=0;				_tipWagLeftCount=0;			}		}		//*****Event Handlers								private function onInit( event:LeapEvent ):void{			debug( "Initialized" );			_active=false;		}				private function onConnect( event:LeapEvent ):void{			debug( "Connected" );			_active=true;		}				private function onDisconnect( event:LeapEvent ):void{			debug( "Disconnected" );			_active=false;		}				private function onExit( event:LeapEvent ):void{			debug( "Exited" );			_active=false;		}				private function onFrame( event:LeapEvent ):void		{			//debug("onFrame");			// Get the most recent _frame and report some basic information			_frame = event.frame;			_hands = _frame.hands;			_fingers = _frame.fingers;			_tools=_frame.tools;			_pointables=_frame.pointables;			_gestures=_frame._gestures;									for each(var hand:Hand in event.frame.hands){				_palmY=hand.palmPosition.y;				_fingerCount=hand.fingers.length;								switch(hand.fingers.length){					//					case 0://						_noFingers=true;//						_gestureStart=true;//						TweenNano.delayedCall(_gestureDuration,endGesture);//						break;										case 1:												//poke						if(hand.palmVelocity.z < -_palmVelocityThreshold && !_gestureStart){							debug("poke");							_poke=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}												//wag						if(hand.palmVelocity.x < _stillVelocityThreshold && 							!_gestureStart && 							_hands.length==0){														if(_fingers[0].tipVelocity.x > _tipVelocityThreshold){								debug("finger wag right");								_tipWagRightCount++;								_gestureStart=true;								TweenNano.delayedCall(_gestureDuration/2,endGesture);							}														if(_fingers[0].tipVelocity.x < -_tipVelocityThreshold){								debug("finger wag left");								_tipWagLeftCount++;								_gestureStart=true;								TweenNano.delayedCall(_gestureDuration/2,endGesture);							}														checkFingerWag();						}												//swipe						if(hand.palmVelocity.x > _palmVelocityThreshold && !_gestureStart){							debug("right1");							_swipeRight1=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}						else if(hand.palmVelocity.x < -_palmVelocityThreshold && !_gestureStart){							debug("left1");							_swipeLeft1=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}						break;										case 2:												//swipe						if(hand.palmVelocity.x > _palmVelocityThreshold && !_gestureStart){							debug("right2");							_swipeRight2=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}						else if(hand.palmVelocity.x < -_palmVelocityThreshold && !_gestureStart){							debug("left2");							_swipeLeft2=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}												break;										case 3:						//debug("3");						if(hand.palmVelocity.x > _palmVelocityThreshold && !_gestureStart){							debug("right3");							_swipeRight3=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}												if(hand.palmVelocity.x < -_palmVelocityThreshold && !_gestureStart){							debug("left3");							_swipeLeft3=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}						break;										case 4:						//debug("4");						if(hand.palmVelocity.x > _palmVelocityThreshold && !_gestureStart){							debug("right4");							_swipeRight4=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}												if(hand.palmVelocity.x < -_palmVelocityThreshold && !_gestureStart){							debug("left4");							_swipeLeft4=true;							_gestureStart=true;							TweenNano.delayedCall(_gestureDuration,endGesture);						}						break;										default:						//debug("total fingers=="+hand.fingers.length);						break;				}			}			//			if(_fingers.length==1 && //				!_gestureStart && //				_hands.length==0){//				//				if(_fingers[0].tipVelocity.x > _tipVelocityThreshold){//					debug("finger wag right");//					_tipWagRightCount++;//					_gestureStart=true;//					TweenNano.delayedCall(_gestureDuration/2,endGesture);//				}//				//				if(_fingers[0].tipVelocity.x < -_tipVelocityThreshold){//					debug("finger wag left");//					_tipWagLeftCount++;//					_gestureStart=true;//					TweenNano.delayedCall(_gestureDuration/2,endGesture);//				}//				//				checkFingerWag();//			}					}				private function onLeapController(e:MuleEvent):void{			/*debug("onLeapController()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onLeapController()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():LeapController{return _instance;}				public function get frame():Frame{return _frame;}		public function get hands():Vector.<Hand>{return _hands;}		public function get fingers():Vector.<Finger>{return _fingers;}		public function get tools():Vector.<Tool>{return _tools;}		public function get pointables():Vector.<Pointable>{return _pointables;}		public function get gestures():Vector.<Gesture>{return _gestures;}				public function get palmY():Number{return _palmY;}		public function get fingerCount():int{return _fingerCount;}		public function get active():Boolean{return _active;}		//*****Utility Functions				//**debug		private function debug(str:String):void{			utils.debug(NAME,str);		}				}//end class}//end packageclass LeapControllerLock{}